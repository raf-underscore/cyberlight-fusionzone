// Copyright Recursoft LLC 2019-2022. All Rights Reserved.

#include "SMGraphK2Node_TextPropertyNode.h"
#include "Widgets/Text/SSMTextProperty.h"
#include "Graph/SMTextPropertyGraph.h"
#include "Commands/SMExtendedEditorCommands.h"

#include "SMTextGraphPropertyVersion.h"

#include "Blueprints/SMBlueprintEditor.h"
#include "Graph/Nodes/SMGraphNode_Base.h"

#include "Widgets/Input/SButton.h"
#include "Components/HorizontalBox.h"
#include "ScopedTransaction.h"

#include "ToolMenuSection.h"

#define LOCTEXT_NAMESPACE "SMTextPropertyNode"

USMGraphK2Node_TextPropertyNode::USMGraphK2Node_TextPropertyNode(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}

void USMGraphK2Node_TextPropertyNode::NotifyFormatTextUpdated(const FText& NewText)
{
	if (LastAutoGeneratedDefaultValue != NewText.ToString())
	{
		bDefaultValueChanged = true;
	}
}

void USMGraphK2Node_TextPropertyNode::Serialize(FArchive& Ar)
{
	Ar.UsingCustomVersion(FSMTextGraphPropertyCustomVersion::GUID);
	Super::Serialize(Ar);

	if (Ar.IsLoading() && Ar.CustomVer(FSMTextGraphPropertyCustomVersion::GUID) < FSMTextGraphPropertyCustomVersion::DefaultsSupported)
	{
		bUpgradingToSupportDefaults = true;
	}
}

void USMGraphK2Node_TextPropertyNode::PostLoad()
{
	Super::PostLoad();
	if (bUpgradingToSupportDefaults)
	{
		SetPropertyDefaultsFromPin();
		bUpgradingToSupportDefaults = false;
	}
}

void USMGraphK2Node_TextPropertyNode::AllocateDefaultPins()
{
	UEdGraphPin* GraphPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Text, TEXT("Result"));

	FSMGraphProperty_Base* Prop = GetPropertyNodeChecked();
	
	const bool bIsReadOnly = Prop->IsVariableReadOnly();
	GraphPin->bNotConnectable = bIsReadOnly;
	GraphPin->bDefaultValueIsReadOnly = bIsReadOnly;
}

bool USMGraphK2Node_TextPropertyNode::IsConnectionDisallowed(const UEdGraphPin* MyPin, const UEdGraphPin* OtherPin, FString& OutReason) const
{
	UEdGraphPin* ResultPin = GetResultPin();
	if (ResultPin && (ResultPin == MyPin || ResultPin == OtherPin))
	{
		if (const FSMGraphProperty_Base* Prop = GetPropertyNodeConst())
		{
			if (Prop->IsVariableReadOnly())
			{
				// We probably want to allow this if the graph is being reformated.
				const USMTextPropertyGraph* TextGraph = CastChecked<USMTextPropertyGraph>(GetPropertyGraph());
				if (TextGraph->IsUpdatingGraph())
				{
					return false;
				}
			}
		}
	}
	
	return Super::IsConnectionDisallowed(MyPin, OtherPin, OutReason);
}

void USMGraphK2Node_TextPropertyNode::ConfigureRuntimePropertyNode()
{
	RuntimeTextProperty.GraphEvaluator = TextProperty.GraphEvaluator;
	RuntimeTextProperty.SetGuid(TextProperty.GetGuid());
	RuntimeTextProperty.SetOwnerGuid(TextProperty.GetOwnerGuid());
	RuntimeTextProperty.TextSerializer = TextProperty.TextSerializer;
	RuntimeTextProperty.Result = TextProperty.Result;
}

FSMGraphProperty_Base_Runtime* USMGraphK2Node_TextPropertyNode::GetRuntimePropertyNode()
{
	return &RuntimeTextProperty;
}

TSharedPtr<SSMGraphProperty_Base> USMGraphK2Node_TextPropertyNode::GetGraphNodeWidget() const
{
	return SNew(SSMTextProperty)
		.GraphNode(const_cast<USMGraphK2Node_TextPropertyNode*>(this))
		.WidgetInfo(&TextProperty.WidgetInfo);
}

void USMGraphK2Node_TextPropertyNode::DefaultPropertyActionWhenPlaced(TSharedPtr<SWidget> Widget)
{
	if (SSMTextProperty* TextWidget = (SSMTextProperty*)Widget.Get())
	{
		TextWidget->ToggleTextEdit(true);
	}
}

void USMGraphK2Node_TextPropertyNode::PinDefaultValueChanged(UEdGraphPin* Pin)
{
	const bool bDefaultValueChangedBeforeParentCall = bDefaultValueChanged;
	Super::PinDefaultValueChanged(Pin);
	if (!bDefaultValueChangedBeforeParentCall && bDefaultValueChanged)
	{
		bDefaultValueChanged = bDefaultValueChangedBeforeParentCall;
	}
}

void USMGraphK2Node_TextPropertyNode::SetPropertyDefaultsFromPin()
{
	if (bSettingPropertyDefaultsFromPin || HasAnyFlags(RF_NeedPostLoad | RF_NeedPostLoadSubobjects))
	{
		return;
	}

	bSettingPropertyDefaultsFromPin = true;

	if (USMNodeInstance* Template = GetOwningTemplate())
	{
		// Ignore REINST classes.
		UClass* Class = Template->GetClass();
		if (Class->GetName().StartsWith(TEXT("REINST_")))
		{
			// Super rare to hit this branch. Likely a problem has already occurred and this is
			// an undo/redo operation.
			return;
		}
		
		USMTextPropertyGraph* TextGraph = CastChecked<USMTextPropertyGraph>(GetPropertyGraph());
		if (UEdGraphPin* FormatPin = TextGraph->GetFormatTextNodePin())
		{
			FSMGraphProperty_Base* GraphProperty = GetPropertyNodeChecked();

			UClass* ClassToUse = Template->GetClass();
			if (FProperty* Property = GraphProperty->MemberReference.ResolveMember<FProperty>(ClassToUse))
			{
				Modify();
				Template->Modify();
				
				FSMTextGraphProperty* TextGraphProperty = Property->ContainerPtrToValuePtr<FSMTextGraphProperty>(Template);
				
				const FText DefaultText = FormatPin->GetDefaultAsText();
				const FString Namespace = FTextInspector::GetNamespace(DefaultText).Get(FString());

				// IMPORTANT: Remove culture settings from the text being stored in the archetype defaults. Without this a reference
				// to the namespace and key will be added and a new key generated everytime the user changes the text in this box.
				TextGraphProperty->Result = FText::AsCultureInvariant(FText::ChangeKey(Namespace, FGuid::NewGuid().ToString(), DefaultText));

				if (USMGraphNode_Base* OwningNode = GetOwningGraphNode())
				{
					if (OwningNode->IsBeingPasted() || OwningNode->IsPreCompiling())
					{
						// Pasting and recompiling will run all construction scripts.
						bSettingPropertyDefaultsFromPin = false;
						return;
					}
				}
			}
		}
	}

	bSettingPropertyDefaultsFromPin = false;
}

void USMGraphK2Node_TextPropertyNode::SetPinValueFromPropertyDefaults(bool bUpdateTemplateDefaults, bool bUseArchetype, bool bForce)
{
	if (bGeneratedDefaultValueBeingSet || bUpgradingToSupportDefaults)
	{
		return;
	}

	if (bResettingProperty)
	{
		// Never reset from the instance.
		bUseArchetype = true;
	}

	if (bDefaultValueChanged && !bForce)
	{
		/*
		 * Assume the pin is accurate and update the default value of the archetype. Pasting nodes doesn't grab the updated value
		 * when a variable name has a special character like `[` or `(` character in it. We think this is a problem with CopyPropertiesForUnrelatedObjects.
		 * Without this code default values may not be set and will require graph evaluation.
		 */
		if (bUpdateTemplateDefaults)
		{
			SetPropertyDefaultsFromPin();
		}
		return;
	}

	if (USMNodeInstance* Template = GetOwningTemplate())
	{
		// Ignore REINST classes.
		UClass* Class = Template->GetClass();
		if (Class->GetName().StartsWith(TEXT("REINST_")))
		{
			return;
		}

		// Switch to the CDO so we can get the real defaults.
		Template = bUseArchetype ? CastChecked<USMNodeInstance>(Class->GetDefaultObject()) : Template;
		USMTextPropertyGraph* TextGraph = CastChecked<USMTextPropertyGraph>(GetPropertyGraph());
		
		if (UEdGraphPin* FormatPin = TextGraph->GetFormatTextNodePin())
		{
			// Only reset if the user hasn't changed the default value.
			if (bForce || !bDefaultValueChanged || FormatPin->DefaultValue == FormatPin->AutogeneratedDefaultValue || FormatPin->DefaultValue == LastAutoGeneratedDefaultValue)
			{
				FSMGraphProperty_Base* GraphProperty = GetPropertyNodeChecked();
				if (FProperty* Property = GraphProperty->MemberReference.ResolveMember<FProperty>(Template->GetClass()))
				{
					FSMTextGraphProperty* TextGraphProperty = Property->ContainerPtrToValuePtr<FSMTextGraphProperty>(Template);
					check(TextGraphProperty);

					Modify();
					FormatPin->Modify();
					
					LastAutoGeneratedDefaultValue = TextGraphProperty->Result.ToString();

					bGeneratedDefaultValueBeingSet = true;
					// Already equal, don't update
					if (!TextGraphProperty->Result.EqualTo(TextGraph->GetPlainTextBody(), ETextComparisonLevel::Quinary))
					{
						TextGraph->SetTextBody(TextGraphProperty->Result);
					
						const UEdGraphSchema_K2* Schema = CastChecked<UEdGraphSchema_K2>(GetSchema());
						Schema->TrySetDefaultValue(*FormatPin, LastAutoGeneratedDefaultValue);
					}
					bGeneratedDefaultValueBeingSet = false;
				}
			}
		}
	}
}

void USMGraphK2Node_TextPropertyNode::Internal_GetContextMenuActionsForOwningNode(const UEdGraph* CurrentGraph,
	const UEdGraphNode* InGraphNode, const UEdGraphPin* InGraphPin, FToolMenuSection& MenuSection, bool bIsDebugging) const
{
	if (!GetPropertyGraph()->IsGraphBeingUsedToEdit() && !bIsDebugging)
	{
		MenuSection.AddMenuEntry(FSMExtendedEditorCommands::Get().StartTextPropertyEdit);
	}
	Super::Internal_GetContextMenuActionsForOwningNode(CurrentGraph, InGraphNode, InGraphPin, MenuSection, bIsDebugging);
}

#undef LOCTEXT_NAMESPACE
